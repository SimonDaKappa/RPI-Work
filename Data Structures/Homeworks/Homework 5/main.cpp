// =====================================================================
// =====================================================================
// NOTE: DO NOT EDIT THIS FILE EXCEPT WHERE INDICATED
// =====================================================================
// =====================================================================


#include <iostream>
#include <cassert>
#include <cstdlib>
#include <string>


// You will write the grid.h file to implement the Grid class and
// helper classes GridIterator and Node.
#include "grid.h"


// prototypes for helper testing functions
void test_example();
void test_iterators();
void test_separation();
void test_iterators_part_2();

void additional_student_tests();


// =====================================================================
// =====================================================================

int main() {

  // =======================================================================
  // NOTE: UNCOMMENT THESE FUNCTIONS AS YOU WORK THROUGH YOUR IMPLEMENTATION
  // =======================================================================

  //test_example();
  //test_iterators();
  //test_separation();
  //test_iterators_part_2();

  additional_student_tests();

}

// =====================================================================
// =====================================================================

void test_example() {
  std::cout << "=====================================================================" << std::endl;
  std::cout << "test_example()" << std::endl;


  // ------------------------------
  // simple construction & printing
  std::cout << "\nA 5x1 horizontal row:" << std::endl;
  Grid<int> horizontal(5,1,42);
  horizontal.print();

  std::cout << "\nA 1x3 vertical column:" << std::endl;
  Grid<int> vertical(1,3,99);
  vertical.print();
  
  std::cout << "\nA 4x3 grid of zeros:" << std::endl;
  Grid<int> grid(4,3);
  assert (grid.getWidth() == 4);
  assert (grid.getHeight() == 3);
  assert (grid.getSize() == 12);
  grid.print();

  
  
  // --------------------------------------------
  // initializing and checking values by index
  // (rather inefficient for this data structure)
  std::cout << "\nNow let's initialize the grid values:" << std::endl;
  int tmp = 1;
  for (int j = 0; j < 3; j++) {
    for (int i = 0; i < 4; i++) {
      //std::cout << "(" << i << "," << j << ") " << tmp << " "; //TEST
      grid.set(i, j, tmp);
      tmp++;
    }
  }
  
  grid.print();

  assert(grid.get(0, 0) == 1);
  assert(grid.get(0, 1) == 5);
  assert(grid.get(2, 2) == 11);

  // ----------------------
  // create basic iterators
  Grid<int>::iterator itr;
  itr = grid.begin_upper_left();
  assert(*itr == 1);
  itr = grid.begin_upper_right();
  assert(*itr == 4);
  itr = grid.begin_lower_left();
  assert(*itr == 9);
  itr = grid.begin_lower_right();
  assert(*itr == 12);

  // -------------------------------
  // combining grids: join and stack
  std::cout << "\nLet's join the vertical column on the right: " << std::endl;
  grid.join(vertical);
  assert (grid.getWidth() == 5);
  assert (grid.getHeight() == 3);
  assert (vertical.getWidth() == 0);
  assert (vertical.getHeight() == 0);
  grid.print();
  
  std::cout << "\nAnd stack the horizontal row on the top: " << std::endl;
  grid.stack(horizontal);
  assert (grid.getWidth() == 5);
  assert (grid.getHeight() == 4);
  assert (horizontal.getWidth() == 0);
  assert (horizontal.getHeight() == 0);
  grid.print();

  std::cout << "\ndone with test_example()" << std::endl;
  
}

// =====================================================================
// =====================================================================

void test_iterators() {

  
  std::cout << "=====================================================================" << std::endl;
  std::cout << "test_iterators()" << std::endl;
  
  std::cout << "\nA 6x4 grid of dots:" << std::endl;
  Grid<char> grid(6,4,'.');
  assert (grid.getWidth() == 6);
  assert (grid.getHeight() == 4);
  grid.print();
  
  std::cout << "\nUse an iterator to walk along a specific path in the grid:" << std::endl;
  Grid<char>::iterator itr  = grid.begin_lower_right();
  assert (*itr == '.');
  *itr = '0';
  itr.left();  *itr = '1';
  itr.up();    *itr = '2';
  itr.up();    *itr = '3';
  itr.left();  *itr = '4';
  itr.left();  *itr = '5';
  itr.left();  *itr = '6';
  itr.down();  *itr = '7';
  itr.right(); *itr = '8';
  itr.down();  *itr = '9';
  grid.print();

  
  std::cout << "\nReset all values in the grid to a specific value" << std::endl;
  grid.reset('?');
  grid.print();
  
  std::cout << "\nLabel by snaking horizontally through the grid:" << std::endl;
  char tmp = 'a';
  itr = grid.begin_snake();
  
  while (itr != grid.end_snake()) {
    assert (*itr == '?');
    *itr = tmp;
    tmp++;
    itr++;
  }
  grid.print();
  
  grid.clear();
  assert (grid.getSize() == 0);
  assert (grid.getWidth() == 0);
  assert (grid.getHeight() == 0);
  
  std::cout << "\ndone with test_iterators()" << std::endl;
  
}

// =====================================================================
// =====================================================================

void test_separation() {
  
  std::cout << "=====================================================================" << std::endl;
  std::cout << "test_separation()" << std::endl;

  std::cout << "\nPrepare an interesting grid:" << std::endl;
  Grid<int> grid(7,5);
  int tmp = 1;
  Grid<int>::iterator itr = grid.begin_snake();
  while (itr != grid.end_snake()) {
    assert (*itr == 0);
    *itr = tmp;
    tmp++;
    itr++;
  }
  grid.print();
  itr = grid.begin_upper_left();
  itr.right().right().down().down();
  assert (*itr == 17);

  
  std::cout << "\nLifting off the top:" << std::endl;
  Grid<int> top;
  assert (top.getSize() == 0 && top.getWidth() == 0 && top.getHeight() == 0);
  grid.lift(itr,top);
  top.print();
  assert (top.getHeight() == 2);

  std::cout << "\nLeaving the rest:" << std::endl;
  grid.print();
  assert (*itr == 17);

  
  std::cout << "\nChopping off the right:" << std::endl;
  Grid<int> side;
  grid.chop(itr,side);
  side.print();

  std::cout << "\nLeaving the rest:" << std::endl;
  grid.print();
  assert (*itr == 17);
  itr.right().down();
  assert (*itr == 25);

  
  std::cout << "\nJoin it back together on the other side:" << std::endl;
  side.join(grid);
  side.print();
  
  std::cout << "\nAnd stack on the top:" << std::endl;
  top.stack(side);
  top.print();
  assert (top.getWidth() == 7);
  assert (top.getHeight() == 5);
  assert (top.getSize() == 35);

  assert (*top.begin_upper_left()  == 17);
  assert (*top.begin_upper_right() == 16);
  assert (*top.begin_lower_right() == 8);
  assert (*top.begin_lower_left()  == 14);
  
  std::cout << "\ndone with test_separation()" << std::endl;
  
}

// =====================================================================
// =====================================================================

void test_iterators_part_2() {
  
  std::cout << "=====================================================================" << std::endl;
  std::cout << "test_iterators_part_2()" << std::endl;

  std::cout << "\nA 6x4 grid of _'s:" << std::endl;
  Grid<char> grid(6,4,'_');  
  grid.print();
  
  std::cout << "\nLabel by spiraling into the grid:" << std::endl;
  char tmp = 'A';
  Grid<char>::iterator itr = grid.begin_spiral();
  //assert(itr == Grid<char>::iterator(grid.get_upper_left()));
  while (itr != grid.end_spiral())
  {
    //std::cout << "loop iteration";
    assert(*itr == '_');
    //std::cout << std::setw(3) << tmp << '\n';
    *itr = tmp;
    tmp++;
    itr++;
    //grid.print();
  }
  grid.print();
  

  std::cout << "\nAnd a larger example:" << std::endl;
  Grid<int> bigger(8,10,0);
  Grid<int>::iterator itr2 = bigger.begin_spiral();
  int tmp2 = 1;
  while (itr2 != bigger.end_spiral()) {
    *itr2 = tmp2;
    tmp2++;
    itr2++;
  }
  bigger.print();

  
  // walking off the board should hit the end iterator
  itr2 = bigger.begin_lower_left();
  assert (*itr2 == 24);
  itr2.right().right();
  assert (*itr2 == 22);
  itr2.down();
  assert (itr2 == bigger.end()); 
  
  itr2 = bigger.begin_upper_right();
  assert (*itr2 == 8);
  itr2.down().down();
  assert (*itr2 == 10);
  itr2.right();
  assert (itr2 == bigger.end());

  
  std::cout << "\nA dereferenced iterator can be an l-value (and modify data):" << std::endl;
  itr2 = bigger.begin_lower_right();
  itr2.up().left().up().left();
  assert (*itr2 == 65);
  *itr2 = 0;
  assert (bigger.get(5,7) == 0);
  
  itr2 = bigger.begin_snake();
  for (int i = 0; i < 19; i++) { itr2++; }
  assert (*itr2 == 58);
  *itr2 = -1;
  assert (bigger.get(3,2) == -1);
  
  bigger.print();
  
  std::cout << "\ndone with test_iterators_part_2()" << std::endl;

}  


// =====================================================================
// =====================================================================

void additional_student_tests() {

  std::cout << "=====================================================================" << std::endl;
  std::cout << "additional_student_tests()" << std::endl;

  /*
    1. Copy Constructor, Assignment Operator
    2. Corner cases! THINK OF THESE!
    3. Destructor
  */
  //Assignment Operator
  //Scope for destructor
  Grid<int> grid1(5, 5, 10);
  {
    grid1.print();
    std::cout << '\n';
    Grid<int> grid2(6, 2, 0);
    int c = 123;
    Grid<int>::iterator itr = grid2.begin_snake();
    while(itr != grid2.end_snake()){
      *itr = c ;
      c--;
      itr++;
    }
    grid2.print();
    std::cout << '\n';
    grid2 = grid1;
    grid2.print();
    std::cout << '\n';
    
    //Lift Chop
    Grid<int> grid3(1, 7, 0); //Single Column Lift Corner Case
    //Single row chop case exact same, I wrote the code for both almost identical.
    grid3.print();
    std::cout << '\n';
    Grid<int> grid4;
    itr = grid3.begin_lower_left().up().up();
    grid3.lift(itr, grid4);
    grid4.print();
    std::cout << "\n";
    Grid<int> grid7(1, 4, 0);
    grid7.print();
    std::cout << '\n';
    grid4.join(grid7);
    grid4.print();
    itr = grid4.begin_upper_left().right();
    grid4.chop(itr, grid7);
    grid4.print();
    std::cout << '\n';

    std::cout<< '\n';
    Grid<int> grid5(1, grid4.getHeight(), 5); //Joining to a lift
    grid4.join(grid5);
    grid4.print();
    std::cout << '\n';

    //Copy Constructor
    Grid<int> grid6(grid4);
    grid6.print();
    std::cout << '\n';
    grid6 = grid2;
    grid6.print();
    std::cout << '\n';

    //Spiral/Snake
    //I really want to test the edge cases on these, I just ran out of time
  }
  // =======================================================================
  // NOTE: WRITE YOUR OWN TEST CASES HERE!
  // =======================================================================

  std::cout << "done with additional_student_tests()" << std::endl;
}

// ======================================================================
// ======================================================================
